/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "package_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>




MsgGetRequest::~MsgGetRequest() throw() {
}


void MsgGetRequest::__set_key(const std::string& val) {
  this->key = val;
}
std::ostream& operator<<(std::ostream& out, const MsgGetRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MsgGetRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MsgGetRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MsgGetRequest");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MsgGetRequest &a, MsgGetRequest &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.__isset, b.__isset);
}

MsgGetRequest::MsgGetRequest(const MsgGetRequest& other0) {
  key = other0.key;
  __isset = other0.__isset;
}
MsgGetRequest& MsgGetRequest::operator=(const MsgGetRequest& other1) {
  key = other1.key;
  __isset = other1.__isset;
  return *this;
}
void MsgGetRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MsgGetRequest(";
  out << "key=" << to_string(key);
  out << ")";
}


MsgSetRequest::~MsgSetRequest() throw() {
}


void MsgSetRequest::__set_key(const std::string& val) {
  this->key = val;
}

void MsgSetRequest::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const MsgSetRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MsgSetRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MsgSetRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MsgSetRequest");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MsgSetRequest &a, MsgSetRequest &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

MsgSetRequest::MsgSetRequest(const MsgSetRequest& other2) {
  key = other2.key;
  value = other2.value;
  __isset = other2.__isset;
}
MsgSetRequest& MsgSetRequest::operator=(const MsgSetRequest& other3) {
  key = other3.key;
  value = other3.value;
  __isset = other3.__isset;
  return *this;
}
void MsgSetRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MsgSetRequest(";
  out << "key=" << to_string(key);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


MsgRemoveRequest::~MsgRemoveRequest() throw() {
}


void MsgRemoveRequest::__set_key(const std::string& val) {
  this->key = val;
}
std::ostream& operator<<(std::ostream& out, const MsgRemoveRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MsgRemoveRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MsgRemoveRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MsgRemoveRequest");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MsgRemoveRequest &a, MsgRemoveRequest &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.__isset, b.__isset);
}

MsgRemoveRequest::MsgRemoveRequest(const MsgRemoveRequest& other4) {
  key = other4.key;
  __isset = other4.__isset;
}
MsgRemoveRequest& MsgRemoveRequest::operator=(const MsgRemoveRequest& other5) {
  key = other5.key;
  __isset = other5.__isset;
  return *this;
}
void MsgRemoveRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MsgRemoveRequest(";
  out << "key=" << to_string(key);
  out << ")";
}


MsgExistRequest::~MsgExistRequest() throw() {
}


void MsgExistRequest::__set_key(const std::string& val) {
  this->key = val;
}
std::ostream& operator<<(std::ostream& out, const MsgExistRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MsgExistRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MsgExistRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MsgExistRequest");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MsgExistRequest &a, MsgExistRequest &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.__isset, b.__isset);
}

MsgExistRequest::MsgExistRequest(const MsgExistRequest& other6) {
  key = other6.key;
  __isset = other6.__isset;
}
MsgExistRequest& MsgExistRequest::operator=(const MsgExistRequest& other7) {
  key = other7.key;
  __isset = other7.__isset;
  return *this;
}
void MsgExistRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MsgExistRequest(";
  out << "key=" << to_string(key);
  out << ")";
}


MsgGetResponse::~MsgGetResponse() throw() {
}


void MsgGetResponse::__set_status(const int32_t val) {
  this->status = val;
}

void MsgGetResponse::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const MsgGetResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MsgGetResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MsgGetResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MsgGetResponse");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MsgGetResponse &a, MsgGetResponse &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

MsgGetResponse::MsgGetResponse(const MsgGetResponse& other8) {
  status = other8.status;
  value = other8.value;
  __isset = other8.__isset;
}
MsgGetResponse& MsgGetResponse::operator=(const MsgGetResponse& other9) {
  status = other9.status;
  value = other9.value;
  __isset = other9.__isset;
  return *this;
}
void MsgGetResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MsgGetResponse(";
  out << "status=" << to_string(status);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


MsgSetResponse::~MsgSetResponse() throw() {
}


void MsgSetResponse::__set_status(const int32_t val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const MsgSetResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MsgSetResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MsgSetResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MsgSetResponse");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MsgSetResponse &a, MsgSetResponse &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

MsgSetResponse::MsgSetResponse(const MsgSetResponse& other10) {
  status = other10.status;
  __isset = other10.__isset;
}
MsgSetResponse& MsgSetResponse::operator=(const MsgSetResponse& other11) {
  status = other11.status;
  __isset = other11.__isset;
  return *this;
}
void MsgSetResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MsgSetResponse(";
  out << "status=" << to_string(status);
  out << ")";
}


MsgRemoveResponse::~MsgRemoveResponse() throw() {
}


void MsgRemoveResponse::__set_result(const bool val) {
  this->result = val;
}
std::ostream& operator<<(std::ostream& out, const MsgRemoveResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MsgRemoveResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MsgRemoveResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MsgRemoveResponse");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MsgRemoveResponse &a, MsgRemoveResponse &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

MsgRemoveResponse::MsgRemoveResponse(const MsgRemoveResponse& other12) {
  result = other12.result;
  __isset = other12.__isset;
}
MsgRemoveResponse& MsgRemoveResponse::operator=(const MsgRemoveResponse& other13) {
  result = other13.result;
  __isset = other13.__isset;
  return *this;
}
void MsgRemoveResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MsgRemoveResponse(";
  out << "result=" << to_string(result);
  out << ")";
}


MsgExistResponse::~MsgExistResponse() throw() {
}


void MsgExistResponse::__set_result(const bool val) {
  this->result = val;
}
std::ostream& operator<<(std::ostream& out, const MsgExistResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MsgExistResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MsgExistResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MsgExistResponse");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MsgExistResponse &a, MsgExistResponse &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

MsgExistResponse::MsgExistResponse(const MsgExistResponse& other14) {
  result = other14.result;
  __isset = other14.__isset;
}
MsgExistResponse& MsgExistResponse::operator=(const MsgExistResponse& other15) {
  result = other15.result;
  __isset = other15.__isset;
  return *this;
}
void MsgExistResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MsgExistResponse(";
  out << "result=" << to_string(result);
  out << ")";
}


